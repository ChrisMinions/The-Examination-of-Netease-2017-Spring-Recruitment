'''
[编程题] 堆砖块
时间限制：1秒
空间限制：32768K
小易有n块砖块，每一块砖块有一个高度。小易希望利用这些砖块堆砌两座相同高度的塔。
为了让问题简单，砖块堆砌就是简单的高度相加，某一块砖只能使用在一座塔中一次。
小易现在让能够堆砌出来的两座塔的高度尽量高，小易能否完成呢。 
输入描述:
输入包括两行： 第一行为整数n(1 ≤ n ≤ 50)，即一共有n块砖块 第二行为n个整数，
表示每一块砖块的高度height[i] (1 ≤ height[i] ≤ 500000)


输出描述:
如果小易能堆砌出两座高度相同的塔，输出最高能拼凑的高度，如果不能则输出-1. 保证答案不大于500000。

输入例子1:
3 2 3 5

输出例子1:
5
'''

'''
解题思路：动态规划
  这道题很难，思路不是我自己想的，是借鉴网上的答案，这里不详写了，有需要可以百度，也可以私聊我，
  运算量很大，通过率只有20%，不过在测试集：
  19
  88242 313 1991 4207 2483 1763 224 16 582 22943 28632 47682 378 90 88 43 117 19 8
  输出99901
  结果正确，应该没错了
'''

'''
代码运行结果：
运行超时:您的程序未能在规定时间内运行结束，请检查是否循环有错或算法复杂度过大。
case通过率为20.00%
'''

n = int(input())
digs = [int(each) for each in input().split()]

max_diff = sum(digs)

dp = [0] + [-1] * (max_diff-1)
for i in range(0, n):
    dp_ = [0] * max_diff
    for j in range(max_diff):
        dp_[j] = dp[j]  # 不放
        if j+digs[i] < max_diff and dp[j+digs[i]] >= 0:  # 放在矮的堆，且放上后不超过高的
            dp_[j] = max(dp_[j], dp[j+digs[i]]+digs[i])
        if digs[i]-j > 0 and dp[digs[i]-j] >= 0:  # 放在矮的堆，且放上后超过高的
            dp_[j] = max(dp_[j], dp[digs[i]-j]+digs[i]-j)
        if j - digs[i] >= 0 and dp[j-digs[i]] >= 0:  # 放在高的堆
            dp_[j] = max(dp_[j], dp[j-digs[i]])
    dp = dp_

if dp[0]:
    print(dp[0])
else:
    print(-1)
